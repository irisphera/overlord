#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
OVERLORD_DIR="$(dirname "${SCRIPT_DIR}")"
IMAGE_NAME="overlord-opencode"
PROVIDERS_FILE="${OVERLORD_DIR}/config/providers.json"
BASE_CONFIG="${OVERLORD_DIR}/config/opencode.json"

# Container name: one per workspace directory (sanitized for docker)
WORKSPACE_SLUG="$(basename "$(pwd)" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]/-/g')"
CONTAINER_NAME="overlord-${WORKSPACE_SLUG}"

# Zellij session name: just the directory basename (no prefix needed)
ZELLIJ_SESSION="$(basename "$(pwd)")"

# Persistent state directory inside the workspace
OVERLORD_STATE_DIR="$(pwd)/.overlord"

# All oh-my-opencode agent and category names (must stay in sync with schema)
ALL_AGENTS='["sisyphus","sisyphus-junior","atlas","OpenCode-Builder","build","plan","oracle","librarian","explore","multimodal-looker","prometheus","metis","momus"]'
ALL_CATEGORIES='["visual-engineering","ultrabrain","artistry","quick","unspecified-low","unspecified-high","writing"]'

show_help() {
    cat << 'USAGE'
overlord - Launch isolated opencode container

USAGE: overlord <command>

COMMANDS:
    zellij         Launch zellij terminal multiplexer (default)
    opencode       Launch opencode directly
    shell          Open a zsh shell in the container
    build          Rebuild the Docker image
    reset          Remove the container (next launch starts fresh)
    help           Show this help

EXAMPLES:
    overlord                         # Launch zellij
    overlord opencode                # Launch opencode directly
    overlord shell                   # Open a shell
    overlord build && overlord       # Rebuild, then launch
    overlord reset && overlord       # Fresh container, then launch

LIFECYCLE:
    First run creates a persistent container per workspace directory.
    Subsequent runs reattach to the existing container.
    Anything installed in the container persists across restarts.
    Use 'reset' to destroy the container and start from a clean image.

    Conversations, memory, and shell history are stored in
    .overlord/ inside the workspace and survive resets.

    Models, providers, and per-agent/category assignments are configured
    in config/providers.json.

ZELLIJ:
    Ctrl+q         Detach from session (container stays alive)
    Ctrl+b         Tab mode
    Alt+n          New pane
    Alt+[ / Alt+]  Switch panes
USAGE
}

build_image() {
    echo "Building overlord image from ${OVERLORD_DIR}..."
    docker build -t "${IMAGE_NAME}" "${OVERLORD_DIR}"
}

ensure_image() {
    if ! docker image inspect "${IMAGE_NAME}" &>/dev/null; then
        build_image
    fi
}

container_state() {
    local state
    state=$(docker inspect --format '{{.State.Status}}' "${CONTAINER_NAME}" 2>/dev/null) || true
    echo "${state:-missing}"
}

# --- Parse command ---

COMMAND="${1:-zellij}"

case "${COMMAND}" in
    help|-h|--help)
        show_help
        exit 0
        ;;
    build)
        build_image
        exit 0
        ;;
    reset)
        echo "Removing container ${CONTAINER_NAME}..."
        docker rm -f "${CONTAINER_NAME}" 2>/dev/null || true
        echo "Done. Run 'overlord' to start fresh."
        exit 0
        ;;
    opencode|shell|zellij)
        ;;
    *)
        echo "Error: unknown command '${COMMAND}'" >&2
        echo "Run 'overlord help' for usage." >&2
        exit 1
        ;;
esac

# --- Require jq ---

if ! command -v jq &>/dev/null; then
    echo "Error: jq is required but not installed." >&2
    echo "  brew install jq  (macOS)" >&2
    echo "  apt install jq   (Debian/Ubuntu)" >&2
    exit 1
fi

# --- Validate config ---

validate_config() {
    local cfg="${PROVIDERS_FILE}"

    # default must reference a valid model alias
    local default_alias
    default_alias=$(jq -r '.default // empty' "${cfg}")
    if [[ -z "${default_alias}" ]]; then
        echo "Error: 'default' not set in ${cfg}" >&2
        exit 1
    fi
    if ! jq -e ".models.\"${default_alias}\"" "${cfg}" &>/dev/null; then
        echo "Error: default '${default_alias}' does not reference a valid model in ${cfg}" >&2
        exit 1
    fi

    # every model must have an id and reference a valid provider
    local invalid
    invalid=$(jq -r '
        .models | to_entries[] |
        select(.value.id == null or .value.id == "") |
        .key' "${cfg}")
    if [[ -n "${invalid}" ]]; then
        echo "Error: model(s) missing 'id' field: ${invalid}" >&2
        exit 1
    fi
    invalid=$(jq -r '
        . as $c |
        .models | to_entries[] |
        select($c.providers[.value.provider] == null) |
        "\(.key) -> \(.value.provider)"' "${cfg}")
    if [[ -n "${invalid}" ]]; then
        echo "Error: model(s) reference unknown provider: ${invalid}" >&2
        exit 1
    fi

    # agent/category overrides must reference valid model aliases (if model specified)
    # Supports both string values and object values with optional .model field
    invalid=$(jq -r '
        . as $c |
        (.agents // {}) | to_entries[] |
        (.value | if type == "string" then . elif .model then .model else null end) as $alias |
        select($alias != null and $c.models[$alias] == null) |
        "\(.key) -> \($alias)"' "${cfg}")
    if [[ -n "${invalid}" ]]; then
        echo "Error: agent override(s) reference unknown model: ${invalid}" >&2
        exit 1
    fi
    invalid=$(jq -r '
        . as $c |
        (.categories // {}) | to_entries[] |
        (.value | if type == "string" then . elif .model then .model else null end) as $alias |
        select($alias != null and $c.models[$alias] == null) |
        "\(.key) -> \($alias)"' "${cfg}")
    if [[ -n "${invalid}" ]]; then
        echo "Error: category override(s) reference unknown model: ${invalid}" >&2
        exit 1
    fi
}

validate_config

# --- Build (if needed) ---

ensure_image

# --- Env vars ---

EXEC_ENV=()

pass_env() {
    local var="$1"
    if [[ -n "${!var:-}" ]]; then
        EXEC_ENV+=(-e "${var}=${!var}")
    fi
}

# Terminal
EXEC_ENV+=(-e "TERM=${TERM:-xterm-256color}")
pass_env COLORTERM
pass_env TERM_PROGRAM
pass_env TERM_PROGRAM_VERSION
pass_env LANG
pass_env LC_ALL

# Common credentials (always forwarded)
pass_env CONTEXT7_API_KEY
pass_env OPENAI_API_KEY
pass_env ANTHROPIC_API_KEY
pass_env ANTHROPIC_MODEL

# --- Collect env vars from all referenced providers ---

# Find every provider actually used by a model alias, then union their env lists.
PROVIDER_ENV_VARS=$(jq -r '
    . as $c |
    [.models[].provider] | unique | map($c.providers[.].env // []) | add | unique | .[]
' "${PROVIDERS_FILE}")
for var in ${PROVIDER_ENV_VARS}; do
    pass_env "${var}"
done

# --- Generate configs ---

# oh-my-opencode.json: per-agent and per-category model assignments.
# For oh-my-opencode, use omo_id if set, otherwise auto-derive from id by
# stripping cross-region prefix (global.) and throughput tier (:max/:min).
# Supports both string values (model alias) and object values (model + reasoning fields).
GENERATED_OMO_JSON=$(jq \
    --argjson allAgents "${ALL_AGENTS}" \
    --argjson allCats "${ALL_CATEGORIES}" '
    . as $c |
    def omo_id(alias):
        $c.models[alias] |
        if .omo_id then .omo_id
        else .id | gsub("/global\\."; "/") | gsub(":(max|min)$"; "")
        end;
    # Resolve a category entry: string → {"model":...}, object → resolve model + extras
    def resolve_cat(name):
        ($c.categories // {})[name] as $val |
        if $val == null then {"model": omo_id($c.default)}
        elif ($val | type) == "string" then {"model": omo_id($val)}
        else
            (($val.model // $c.default) as $alias |
             {"model": omo_id($alias)} + ($val | del(.model)))
        end;
    # Resolve an agent entry: string → {"model":...}, object → resolve model + extras
    def resolve_agent(name):
        ($c.agents // {})[name] as $val |
        if $val == null then {"model": omo_id($c.default)}
        elif ($val | type) == "string" then {"model": omo_id($val)}
        else
            (if $val.model then {"model": omo_id($val.model)} else {} end) +
            ($val | del(.model))
        end;
    {
        "$schema": "https://raw.githubusercontent.com/code-yeongyu/oh-my-opencode/master/assets/oh-my-opencode.schema.json",
        "sisyphus_agent": {
            "planner_enabled": true,
            "replace_plan": true
        },
        "categories": ($allCats | map({(.): resolve_cat(.)}) | add),
        "agents": ($allAgents | map({(.): resolve_agent(.)}) | add)
    }
' "${PROVIDERS_FILE}")

# opencode.json: merge base config with provider definitions, model registrations,
# and per-model options.  Each model is registered under its provider so opencode
# can discover it.
GENERATED_OPENCODE_JSON=$(jq --slurpfile base "${BASE_CONFIG}" '
    . as $c |
    # Build provider object: start with each provider opencode config (npm/name),
    # then add all models grouped under their provider.
    [
        $c.providers | to_entries[] | select(.value.opencode != null) |
        .key as $prov |
        .value.opencode * {
            "models": (
                [ $c.models | to_entries[] | select(.value.provider == $prov) |
                  # Strip "provider/" prefix to get bare model name
                  (.value.id | split("/")[1:] | join("/")) as $bare |
                  # Build model entry: name + options (if present)
                  { ($bare): (
                      (if .value.name then {"name": .value.name} else {} end) *
                      (if .value.options then {"options": .value.options} else {} end)
                  )}
                ] | add // {}
            )
        } | {($prov): .}
    ] | add // {} |
    # Default model id
    $c.models[$c.default].id as $model |
    # Merge with base config
    $base[0] * {"provider": .} | .model = $model
' "${PROVIDERS_FILE}")

# --- Container lifecycle ---

STATE=$(container_state)

ensure_state_dir() {
    mkdir -p "${OVERLORD_STATE_DIR}/opencode-data" "${OVERLORD_STATE_DIR}/zsh-data"
    # Ensure .overlord/ is git-ignored in the workspace
    local gi="$(pwd)/.gitignore"
    if [[ -f "${gi}" ]]; then
        grep -qxF '.overlord/' "${gi}" 2>/dev/null || echo '.overlord/' >> "${gi}"
    else
        echo '.overlord/' > "${gi}"
    fi
}

ensure_running() {
    case "${STATE}" in
        missing)
            echo "Creating container ${CONTAINER_NAME}..."
            ensure_state_dir

            DOCKER_ARGS=(
                -d
                --name "${CONTAINER_NAME}"
                --security-opt label=disable
                --security-opt seccomp=unconfined
                -v "$(pwd):/workspace:rw"
                -v /var/run/docker.sock:/var/run/docker.sock
                -v "$(pwd)/.overlord/opencode-data:/home/overlord/.local/share/opencode"
                -v "$(pwd)/.overlord/zsh-data:/home/overlord/.zsh_data"
                "${EXEC_ENV[@]}"
            )

            if [[ -f "${HOME}/.gitconfig" ]]; then
                DOCKER_ARGS+=(-v "${HOME}/.gitconfig:/home/overlord/.gitconfig:ro")
            fi
            if [[ -d "${HOME}/.ssh" ]]; then
                DOCKER_ARGS+=(-v "${HOME}/.ssh:/home/overlord/.ssh:ro")
            fi

            docker run "${DOCKER_ARGS[@]}" "${IMAGE_NAME}" sleep infinity >/dev/null
            ;;

        exited)
            echo "Starting container ${CONTAINER_NAME}..."
            docker start "${CONTAINER_NAME}" >/dev/null
            ;;

        running)
            ;;

        *)
            echo "Error: Container ${CONTAINER_NAME} is in unexpected state: ${STATE}" >&2
            echo "Try: overlord reset" >&2
            exit 1
            ;;
    esac
}

ensure_running

EXEC_USER="overlord"

# --- Fix workspace permissions for rootless Podman ---
# Rootless Podman maps host UID to container UID 0 (root).
# The overlord user (UID 33333) sees mounted files as "others".
# macOS default umask omits the execute bit on directories for
# group/others, which prevents directory traversal inside the
# container. Adding +X (execute on directories only) fixes this.
chmod -R a+X "$(pwd)" 2>/dev/null || true

# --- Inject configs into container ---

printf '%s\n' "${GENERATED_OPENCODE_JSON}" | \
    docker exec -i "${CONTAINER_NAME}" sh -c 'cat > /home/overlord/.config/opencode/opencode.json'
OPENCODE_COMPACT=$(echo "${GENERATED_OPENCODE_JSON}" | jq -c .)
EXEC_ENV+=(-e "OPENCODE_CONFIG_CONTENT=${OPENCODE_COMPACT}")
printf 'export OPENCODE_CONFIG_CONTENT=%q\n' "${OPENCODE_COMPACT}" | \
    docker exec -i "${CONTAINER_NAME}" sh -c 'cat > /home/overlord/.overlord-env'
docker exec "${CONTAINER_NAME}" sh -c \
    'grep -q overlord-env /home/overlord/.zshrc 2>/dev/null || echo "[ -f ~/.overlord-env ] && . ~/.overlord-env" >> /home/overlord/.zshrc'
docker exec "${CONTAINER_NAME}" sh -c \
    'grep -q zsh_data /home/overlord/.zshrc 2>/dev/null || echo "export HISTFILE=~/.zsh_data/.zsh_history" >> /home/overlord/.zshrc'

OMO_DIR=/home/overlord/.config/opencode
for ext in json jsonc; do
    printf '%s\n' "${GENERATED_OMO_JSON}" | \
        docker exec -i "${CONTAINER_NAME}" sh -c "cat > ${OMO_DIR}/oh-my-opencode.${ext}"
done

cat "${OVERLORD_DIR}/config/zellij-config.kdl" | \
    docker exec -i "${CONTAINER_NAME}" sh -c 'cat > /home/overlord/.config/zellij/config.kdl'

# --- Fix permissions (single pass for all injected configs + volumes) ---
# chown sets ownership; chmod a+rwX is the fallback for rootless Podman
# where UID namespace mapping makes chown ineffective.
docker exec "${CONTAINER_NAME}" sh -c '
    chmod 755 /home/overlord
    chown -R overlord:overlord \
        /home/overlord/.config \
        /home/overlord/.oh-my-zsh \
        /home/overlord/.overlord-env \
        /home/overlord/.zshrc \
        /home/overlord/.cache \
        /home/overlord/.local/share/opencode \
        /home/overlord/.zsh_data \
        2>/dev/null || true
    chmod -R a+rwX \
        /home/overlord/.local \
        /home/overlord/.zsh_data \
        /home/overlord/.cache \
        2>/dev/null || true
'

# --- Fix cross-platform native modules ---
docker exec -u "${EXEC_USER}" "${CONTAINER_NAME}" bash -c '
    if [ -d /workspace/node_modules ] && [ -f /workspace/package.json ]; then
        MARKER=/workspace/node_modules/.overlord-platform
        CURRENT="linux-$(uname -m)"
        if [ ! -f "$MARKER" ] || [ "$(cat "$MARKER" 2>/dev/null)" != "$CURRENT" ]; then
            echo "==> Fixing native dependencies for ${CURRENT}..."
            cd /workspace && npm install --no-audit --no-fund 2>&1 | tail -5
            echo "$CURRENT" > "$MARKER"
            echo "==> Done."
        fi
    fi
'

# --- Ensure zellij cache dir is writable (rootless Podman UID mapping can break chown) ---
docker exec "${CONTAINER_NAME}" sh -c \
    'mkdir -p /home/overlord/.cache/zellij && chown -R overlord:overlord /home/overlord/.cache/zellij; chmod -R a+rwX /home/overlord/.cache'

# --- Launch ---
case "${COMMAND}" in
    opencode)
        docker exec -it -w /workspace -u "${EXEC_USER}" "${EXEC_ENV[@]}" "${CONTAINER_NAME}" \
            opencode
        ;;
    shell)
        docker exec -it -w /workspace -u "${EXEC_USER}" "${EXEC_ENV[@]}" "${CONTAINER_NAME}" \
            zsh -il
        ;;
    zellij)
        docker exec -it -u "${EXEC_USER}" "${EXEC_ENV[@]}" "${CONTAINER_NAME}" \
            zellij attach "${ZELLIJ_SESSION}" --create
        ;;
esac
